{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["AWS","require","config","region","credentials","CognitoIdentityCredentials","IdentityPoolId","rekog","Rekognition","App","useState","setIsLoading","uuidv4","collectionId","setCollectionId","aboutToStart","setAboutToStart","trainingTheRobot","setTrainingTheRobot","robotIsReady","setRobotIsReady","a","params","CollectionId","createCollection","promise","console","log","message","listCollections","collections","JSON","stringify","readFileAsync","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsArrayBuffer","indexFace","e","files","target","Blob","buffer","Error","Image","Bytes","MaxFaces","indexFaces","UnindexedFaces","length","searchFacesByImage","FaceMatches","window","alert","similarity","Similarity","className","onClick","onChange","type","accept","capture","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.21eed841.chunk.js","sourcesContent":["/// <reference types=\"aws-sdk\" />\n\nimport React, { useState, ChangeEvent, } from \"react\";\nimport './App.css';\nimport { v4 as uuidv4 } from 'uuid';\nimport Rekognition, { IndexFacesRequest, SearchFacesByImageRequest, DeleteCollectionRequest } from \"aws-sdk/clients/rekognition\";\n\nconst AWS = require('aws-sdk');\n\n// Initialize the Amazon Cognito credentials provider\nAWS.config.region = 'eu-west-1'; // Region\nAWS.config.credentials = new AWS.CognitoIdentityCredentials({\n    IdentityPoolId: 'eu-west-1:4a8f8cca-1fe0-4ce5-843c-3118a21061f6',\n});\nconst rekog: AWS.Rekognition = new AWS.Rekognition();\n\nfunction App() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [collectionId, setCollectionId] = useState<string>(uuidv4());\n  const [aboutToStart, setAboutToStart] = useState(true);\n  const [trainingTheRobot, setTrainingTheRobot] = useState(false);\n  const [robotIsReady, setRobotIsReady] = useState(false);\n\n  async function createCollection() {\n    setIsLoading(true);\n    try {\n      const params = {\n        CollectionId: collectionId\n       };\n      await rekog.createCollection(params).promise();\n      setCollectionId(collectionId);\n      setAboutToStart(false);\n      setTrainingTheRobot(true);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }\n\n  async function listCollections() {\n    const collections = await rekog.listCollections({}).promise();\n    console.log(JSON.stringify(collections,null,2));\n  }\n\n  function readFileAsync(file: Blob): Promise<string | ArrayBuffer | null> {\n    return new Promise((resolve, reject) => {\n      let reader: FileReader = new FileReader();\n  \n      reader.onload = () => {\n        resolve(reader.result);\n      };\n  \n      reader.onerror = reject;\n  \n      reader.readAsArrayBuffer(file);\n      // thanks https://simon-schraeder.de/posts/filereader-async/\n    })\n  }\n\n  async function indexFace(e: ChangeEvent<HTMLInputElement>) {\n    const files = e.target.files ? e.target.files : [new Blob()];\n    setIsLoading(true);\n    try {\n      const buffer = await readFileAsync(files[0]);\n      if (buffer == null) throw new Error('Error reading file');\n\n      const params: IndexFacesRequest = {\n        CollectionId: collectionId,\n        Image: {\n          Bytes: buffer\n        },\n        MaxFaces: 1,\n      };\n      const result: Rekognition.IndexFacesResponse  = await rekog.indexFaces(params).promise();\n      if (result.UnindexedFaces?.length != null && result.UnindexedFaces?.length > 0) {\n        // throw new Error(result.UnindexedFaces?.length + 1 + ' faces were identified - please add a photo with only one face');\n      }\n      setRobotIsReady(true);\n      setIsLoading(false);\n    } catch (e) {\n      console.log(e.message);\n      setIsLoading(false);\n      // if e message is that theres more than 1 face, let the user know\n    }\n  }\n\n  async function searchFace(e: ChangeEvent<HTMLInputElement>) {\n    const files = e.target.files ? e.target.files : [new Blob()];\n    setIsLoading(true);\n    try {\n      const buffer = await readFileAsync(files[0]);\n      if (buffer == null) throw new Error('Error reading file');\n\n      const params: SearchFacesByImageRequest = {\n        CollectionId: collectionId,\n        Image: {\n          Bytes: buffer\n        },\n        MaxFaces: 1,\n      };\n      const result: Rekognition.SearchFacesByImageResponse  = await rekog.searchFacesByImage(params).promise();\n      if (!result.FaceMatches) return;\n      if (result.FaceMatches?.length == 0) {\n        window.alert('This is definitely not your friend. Abort!')\n        setIsLoading(false);\n        return;\n      }\n      if (result.FaceMatches[0]) {\n        const similarity = result.FaceMatches[0].Similarity;\n        if (!similarity) return;\n        let message: string;\n        switch (true) {\n          case (similarity < 50):\n            message = 'This is probably not your friend (less than 50% similarity)';\n            break;\n          case (similarity < 75):\n            message = 'This could be, but probability is not, your friend (less than 75% similarity) - worth a go?'\n            break;\n          case (similarity < 90):\n            message = 'This is probably your friend (greater than 75% similarity)! Say hello!'\n            break;\n          case (similarity < 99.5):\n            message = 'This is almost certainly your friend (greater than 90% similarity)! Say hello!'\n            break;\n          case (similarity <= 100):\n            message = 'This is DEFINITELY your friend (100% similarity score)!'\n            break;\n          default:\n            message = 'Something went wrong, sorry!';\n        }\n        window.alert(message);\n      }\n    } catch (e) {\n      console.log(e.message);\n      setIsLoading(false);\n      // if e message is that theres more than 1 face, let the user know\n    }\n  }\n\n  function renderTrainingPhotoUpload() {\n    return (\n      <div>\n        <h2>Provide at least one photo of your friend (the more the better)</h2>\n        <p>Note: we do not store your photos. Instead, facial features are analysed and those are what is used to recognise similarities. Your collection of data will be deleted automatically within 24 hours.</p>\n        <input onChange={indexFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n        <input onChange={indexFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n        <input onChange={indexFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n      </div>\n    )\n  }\n  // https://medium.com/better-programming/handling-file-inputs-with-javascript-9f2d3a007f05 ; https://tympanus.net/codrops/2015/09/15/styling-customizing-file-inputs-smart-way/ - make nicer looking drop areas and filepicker\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h2>\n          Ever forget your glasses and fail to recognise your friend? ü§¶‚Äç‚ôÄÔ∏è\n        </h2>\n        <h3>\n          No? But <i>what if!?</i> Keep calm and use this robot to help you recognise them üëÄ\n        </h3>\n        <p>\n          Simply:\n          <ul>\n            <li>\n              <b>Teach the robot</b> by uploading a few photos of your friend's face üì∏\n            </li>\n            <li>\n              <b>Use your new cyborg skill</b> by subtly snapping a photo of their face and we'll tell you if it's your friend! üëã\n            </li>\n          </ul>\n        </p>\n      </header>\n      <body>\n        {aboutToStart &&\n          <div>\n            <h2>Ready to get started?!</h2>\n            <button onClick={createCollection}>Yes!</button>\n            <button onClick={listCollections}>list!</button>\n          </div>\n        }\n        {trainingTheRobot && renderTrainingPhotoUpload()}\n        {robotIsReady &&\n          <div>\n          <h2>The robot has been trained! Snap a photo of your 'friend' and we'll tell you if it's your friend</h2>\n          <input onChange={searchFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n          </div>\n        }\n      </body>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}