{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["AWS","config","region","credentials","CognitoIdentityCredentials","IdentityPoolId","rekog","Rekognition","App","useState","setIsLoading","uuidv4","collectionId","setCollectionId","aboutToStart","setAboutToStart","trainingTheRobot","setTrainingTheRobot","robotIsReady","setRobotIsReady","facesInCollectionCount","setFacesInCollectionCount","a","params","CollectionId","createCollection","promise","console","log","message","readFileAsync","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsArrayBuffer","indexFace","e","files","target","Blob","buffer","Error","Image","Bytes","MaxFaces","indexFaces","FaceRecords","length","window","alert","document","getElementById","value","searchFacesByImage","FaceMatches","similarity","Similarity","className","onClick","id","onChange","type","accept","capture","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.f796827b.chunk.js","sourcesContent":["/// <reference types=\"aws-sdk\" />\n\nimport React, { useState, ChangeEvent, } from \"react\";\nimport './App.css';\nimport { v4 as uuidv4 } from 'uuid';\nimport AWS from 'aws-sdk';\nimport Rekognition, { CreateCollectionRequest, IndexFacesRequest, SearchFacesByImageRequest } from \"aws-sdk/clients/rekognition\";\n\nAWS.config.region = 'eu-west-1';\nAWS.config.credentials = new AWS.CognitoIdentityCredentials({\n    IdentityPoolId: 'eu-west-1:4a8f8cca-1fe0-4ce5-843c-3118a21061f6',\n});\nconst rekog: AWS.Rekognition = new AWS.Rekognition();\n\nfunction App() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [collectionId, setCollectionId] = useState<string>(uuidv4());\n  const [aboutToStart, setAboutToStart] = useState(true);\n  const [trainingTheRobot, setTrainingTheRobot] = useState(false);\n  const [robotIsReady, setRobotIsReady] = useState(false);\n  const [facesInCollectionCount, setFacesInCollectionCount] = useState(0);\n\n  async function createCollection() {\n    setIsLoading(true);\n    try {\n      const params: CreateCollectionRequest = {\n        CollectionId: collectionId\n       };\n      await rekog.createCollection(params).promise();\n      setCollectionId(collectionId);\n      setAboutToStart(false);\n      setTrainingTheRobot(true);\n    } catch (e) {\n      console.log(e.message);\n    }\n  }\n\n  function readFileAsync(file: Blob): Promise<string | ArrayBuffer | null> {\n    return new Promise((resolve, reject) => {\n      let reader: FileReader = new FileReader();\n  \n      reader.onload = () => {\n        resolve(reader.result);\n      };\n  \n      reader.onerror = reject;\n  \n      reader.readAsArrayBuffer(file);\n      // thanks https://simon-schraeder.de/posts/filereader-async/\n    })\n  }\n\n  async function indexFace(e: ChangeEvent<HTMLInputElement>) {\n    const files = e.target.files ? e.target.files : [new Blob()];\n    setIsLoading(true);\n    try {\n      const buffer = await readFileAsync(files[0]);\n      if (buffer == null) throw new Error('Error reading file');\n\n      const params: IndexFacesRequest = {\n        CollectionId: collectionId,\n        Image: {\n          Bytes: buffer\n        },\n        MaxFaces: 1,\n      };\n      const result: Rekognition.IndexFacesResponse  = await rekog.indexFaces(params).promise();\n      if (result.FaceRecords && result.FaceRecords.length === 0) {\n        window.alert('Woops, no face was registered in that photo. Can you try a different one?');\n      } else {\n        setRobotIsReady(true);\n        setFacesInCollectionCount(facesInCollectionCount + 1);\n        ((document.getElementById(\"uploadTrainingPhoto\")) as HTMLInputElement).value = \"\";\n      }\n    } catch (e) {\n      console.log(e.message);\n    }\n    setIsLoading(false);\n  }\n\n  async function searchFace(e: ChangeEvent<HTMLInputElement>) {\n    const files = e.target.files ? e.target.files : [new Blob()];\n    setIsLoading(true);\n    try {\n      const buffer = await readFileAsync(files[0]);\n      if (buffer == null) throw new Error('Error reading file');\n\n      const params: SearchFacesByImageRequest = {\n        CollectionId: collectionId,\n        Image: {\n          Bytes: buffer\n        },\n        MaxFaces: 1,\n      };\n      const result: Rekognition.SearchFacesByImageResponse  = await rekog.searchFacesByImage(params).promise();\n      if (!result.FaceMatches) return;\n      if (result.FaceMatches?.length == 0) {\n        window.alert('This is definitely not your friend. Abort!')\n        setIsLoading(false);\n        ((document.getElementById(\"uploadFriendPhoto\")) as HTMLInputElement).value = \"\";\n        return;\n      }\n      if (result.FaceMatches[0]) {\n        const similarity = result.FaceMatches[0].Similarity;\n        if (!similarity) return;\n        let message: string;\n        switch (true) {\n          case (similarity < 50):\n            message = 'This is probably not your friend (less than 50% similarity)';\n            break;\n          case (similarity < 75):\n            message = 'This could be, but probability is not, your friend (less than 75% similarity) - worth a go?'\n            break;\n          case (similarity < 90):\n            message = 'This is probably your friend (greater than 75% similarity)! Say hello!'\n            break;\n          case (similarity < 99.5):\n            message = 'This is almost certainly your friend (greater than 90% similarity)! Say hello!'\n            break;\n          case (similarity <= 100):\n            message = 'This is DEFINITELY your friend (100% similarity score)!'\n            break;\n          default:\n            message = 'Something went wrong, sorry!';\n        }\n        window.alert(message);\n        ((document.getElementById(\"uploadFriendPhoto\")) as HTMLInputElement).value = \"\";\n      }\n    } catch (e) {\n      console.log(e.message);\n      setIsLoading(false);\n      ((document.getElementById(\"uploadFriendPhoto\")) as HTMLInputElement).value = \"\";\n    }\n  }\n\n  function renderHeadingForTrainingPhotoUpload() {\n    if (facesInCollectionCount === 0) {\n      return <h2>Provide at least one photo of your friend (the more the better)</h2>\n    }\n    else if (facesInCollectionCount > 0 && facesInCollectionCount < 2) {\n      return <h2>Great stuff, you've added a photo. Got one more?</h2>\n    }\n    else {\n      return <h2>Great stuff! you've added {facesInCollectionCount} photos so far.</h2>\n    }\n  }\n\n  function renderTrainingPhotoUpload() {\n    return (\n      <div>\n        {renderHeadingForTrainingPhotoUpload()}\n        <input id=\"uploadTrainingPhoto\" onChange={indexFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n      </div>\n    )\n  }\n  // Styling TODO:\n  // nicer looking photo inputs https://medium.com/better-programming/handling-file-inputs-with-javascript-9f2d3a007f05 ; https://tympanus.net/codrops/2015/09/15/styling-customizing-file-inputs-smart-way/ - make nicer looking drop areas and filepicker\n  // add spinners for loading states\n  // add nicer modal instead of window alert?\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h2>\n          Ever forget your glasses and fail to recognise your friend? ü§¶‚Äç‚ôÄÔ∏è\n        </h2>\n        <h3>\n          No? But <i>what if!?</i> Keep calm and use this robot to help you recognise them üëÄ\n        </h3>\n        <p>\n          Simply:\n          <ul>\n            <li>\n              <b>Teach the robot</b> by uploading a few photos of your friend's face üì∏\n            </li>\n            <li>\n              <b>Use your new cyborg skill</b> by subtly snapping a photo of their face and we'll tell you if it's your friend! üëã\n            </li>\n          </ul>\n        </p>\n      </header>\n      <body>\n        {aboutToStart &&\n          <div>\n            <h2>Ready to get started?!</h2>\n            <button onClick={createCollection}>Yes!</button>\n          </div>\n        }\n        {trainingTheRobot && renderTrainingPhotoUpload()}\n        {robotIsReady &&\n          <div>\n            <h2>The robot has been trained! Snap a photo of your 'friend' and we'll tell you if it's your friend</h2>\n            <input id=\"uploadFriendPhoto\" onChange={searchFace} type=\"file\" accept=\"image/*\" capture=\"camera\"></input>\n          </div>\n        }\n        <p>Note: I do not store your photos. Facial features are extracted from photos and used to recognise similarities. Your data will only be used by you and will be deleted within 24 hours.</p>\n      </body>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}